flatdrive/
│
├── contract/
│   └── FlatDriveVaultV5.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IERC20 {
    function decimals() external view returns (uint8);
    function balanceOf(address a) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function transferFrom(address from,address to,uint256 value) external returns (bool);
    function allowance(address owner,address spender) external view returns (uint256);
}

contract FlatDriveVaultV5 {
    IERC20 public immutable token;
    address public owner;
    address public player;

    uint256 public fundBalance;
    uint256 public playerBalance;
    uint256 public backendBalance;

    uint256 public constant WITHDRAW_FEE_BPS = 500; 
    uint256 public constant BPS_DEN = 10000;

    uint256 public constant PLAYER_BPS = 9000;
    uint256 public constant FUND_BPS   = 700;
    uint256 public constant BACKEND_BPS= 300;

    uint256 public minWithdraw = 50 * 1e6;

    event Credited(uint256 totalUsd, uint256 toPlayer, uint256 toFund, uint256 toBackend);
    event WithdrawnForPlayer(address indexed to, uint256 gross, uint256 fee, uint256 net);
    event FundConvertedToPlayer(uint256 amount);
    event FundWithdrawn(address indexed to, uint256 amount);
    event BackendWithdrawn(address indexed to, uint256 amount);
    event OwnerChanged(address indexed newOwner);
    event PlayerChanged(address indexed newPlayer);
    event MinWithdrawChanged(uint256 newMin);

    modifier onlyOwner() { require(msg.sender == owner, "only owner"); _; }
    modifier onlyPlayer(){ require(msg.sender == player, "only player"); _; }

    constructor(address usdtToken, address playerAddress) {
        require(usdtToken != address(0), "bad token");
        owner = msg.sender;
        token = IERC20(usdtToken);
        player = playerAddress;
    }

    function setOwner(address newOwner) external onlyOwner {
        require(newOwner != address(0), "bad owner");
        owner = newOwner;
        emit OwnerChanged(newOwner);
    }
    function setPlayer(address newPlayer) external onlyOwner {
        require(newPlayer != address(0), "bad player");
        player = newPlayer;
        emit PlayerChanged(newPlayer);
    }
    function setMinWithdraw(uint256 newMin) external onlyOwner {
        require(newMin > 0, "bad min");
        minWithdraw = newMin;
        emit MinWithdrawChanged(newMin);
    }

    function credit(uint256 totalUsdAmount) external onlyOwner {
        require(totalUsdAmount > 0, "zero");
        uint256 toPlayer  = (totalUsdAmount * PLAYER_BPS) / BPS_DEN;
        uint256 toFund    = (totalUsdAmount * FUND_BPS) / BPS_DEN;
        uint256 toBackend = totalUsdAmount - toPlayer - toFund;

        playerBalance += toPlayer;
        fundBalance   += toFund;
        backendBalance += toBackend;

        emit Credited(totalUsdAmount, toPlayer, toFund, toBackend);
    }

    function withdrawForPlayer(uint256 amount, address to) external onlyOwner {
        require(to != address(0), "bad to");
        require(amount >= minWithdraw, "below min");
        require(playerBalance >= amount, "insufficient player balance");

        playerBalance -= amount;

        uint256 fee = (amount * WITHDRAW_FEE_BPS) / BPS_DEN;
        uint256 net = amount - fee;

        fundBalance += fee;

        require(token.transfer(to, net), "token transfer failed");
        emit WithdrawnForPlayer(to, amount, fee, net);
    }

    function ownerWithdrawBackend(uint256 amount, address to) external onlyOwner {
        require(to != address(0), "bad to");
        require(amount > 0 && amount <= backendBalance, "bad amount");
        backendBalance -= amount;
        require(token.transfer(to, amount), "token transfer failed");
        emit BackendWithdrawn(to, amount);
    }

    function convertFundToPlayer(uint256 amount) external onlyOwner {
        require(amount > 0 && amount <= fundBalance, "bad amount");
        fundBalance -= amount;
        playerBalance += amount;
        emit FundConvertedToPlayer(amount);
    }

    function ownerWithdrawFund(uint256 amount, address to) external onlyOwner {
        require(to != address(0), "bad to");
        require(amount > 0 && amount <= fundBalance, "bad amount");
        fundBalance -= amount;
        require(token.transfer(to, amount), "token transfer failed");
        emit FundWithdrawn(to, amount);
    }

    function ownerDeposit(uint256 amount) external onlyOwner {
        require(amount > 0, "zero");
        require(token.transferFrom(msg.sender, address(this), amount), "transferFrom failed");
    }

    function contractTokenBalance() external view returns (uint256) {
        return token.balanceOf(address(this));
    }
}
│
├── backend/
│   ├── server.js
import express from "express";
import cors from "cors";
import bodyParser from "body-parser";
import dotenv from "dotenv";
import TronWeb from "tronweb";
import fs from "fs";

dotenv.config();

const {
  TRON_PRIVATE_KEY,
  PLAYER_ADDRESS,
  USDT_TOKEN,
  CONTRACT_ADDRESS,
  BACKEND_USDT_RECEIVER,
  TRON_FULLNODE = "https://api.trongrid.io",
  TRON_SOLIDITY = "https://api.trongrid.io",
  TRON_EVENT = "https://api.trongrid.io",
  PORT = 3000
} = process.env;

if (!TRON_PRIVATE_KEY || !PLAYER_ADDRESS || !USDT_TOKEN) {
  console.error("ضع TRON_PRIVATE_KEY و PLAYER_ADDRESS و USDT_TOKEN في .env");
  process.exit(1);
}

const artifactPath = "./../contract/FlatDriveVault.json";
if (!fs.existsSync(artifactPath)) {
  console.error("ضع ABI+bytecode في contract/FlatDriveVault.json بعد الكومبايل");
  process.exit(1);
}
const artifact = JSON.parse(fs.readFileSync(artifactPath, "utf8"));
const abi = artifact.abi;

const tronWeb = new TronWeb(TRON_FULLNODE, TRON_SOLIDITY, TRON_EVENT, TRON_PRIVATE_KEY);

const toMicro = (v) => Math.floor(Number(v) * 1e6);

let contract = null;
async function getContract() {
  if (!contract) {
    if (!CONTRACT_ADDRESS) throw new Error("CONTRACT_ADDRESS غير مضبوطة في .env");
    contract = await tronWeb.contract(abi, CONTRACT_ADDRESS);
  }
  return contract;
}

const app = express();
app.use(cors());
app.use(bodyParser.json());

app.get("/", (req,res)=> res.send("FlatDrive backend running"));

app.get("/balances", async (req,res) => {
  try {
    const c = await getContract();
    const [pb, fb, bb, cb] = await Promise.all([
      c.playerBalance().call(),
      c.fundBalance().call(),
      c.backendBalance().call(),
      c.contractTokenBalance().call()
    ]);
    res.json({
      playerBalance: Number(pb)/1e6,
      fundBalance: Number(fb)/1e6,
      backendBalance: Number(bb)/1e6,
      contractToken: Number(cb)/1e6,
      player: PLAYER_ADDRESS,
      contract: CONTRACT_ADDRESS
    });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

app.post("/credit", async (req,res) => {
  try {
    const { totalUsd } = req.body;
    if (!totalUsd || Number(totalUsd) <= 0) return res.status(400).json({ error: "totalUsd مطلوب" });
    const c = await getContract();
    const amount = toMicro(totalUsd);
    const tx = await c.credit(amount).send({ feeLimit: 100_000_000 });
    res.json({ ok: true, tx });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

app.post("/withdraw", async (req,res) => {
  try {
    const { amount, to } = req.body;
    if (!amount || Number(amount) < 50) return res.status(400).json({ error: "الحد الأدنى 50 USDT" });
    if (!to || !to.startsWith("T")) return res.status(400).json({ error: "عنوان TRON غير صالح" });
    const c = await getContract();
    const micro = toMicro(amount);
    const tx = await c.withdrawForPlayer(micro, to).send({ feeLimit: 100_000_000 });
    res.json({ ok: true, tx });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

app.post("/withdrawBackend", async (req,res) => {
  try {
    const { amount, to } = req.body;
    const dst = to || BACKEND_USDT_RECEIVER;
    if (!amount || Number(amount) <= 0) return res.status(400).json({ error: "amount مطلوب" });
    if (!dst) return res.status(400).json({ error: "to مطلوب أو اضبط BACKEND_USDT_RECEIVER" });
    const c = await getContract();
    const micro = toMicro(amount);
    const tx = await c.ownerWithdrawBackend(micro, dst).send({ feeLimit: 100_000_000 });
    res.json({ ok: true, tx });
  } catch (e) {
    res.status(500).json({ error: e.message });
  }
});

app.listen(PORT, () => console.log(`FlatDrive backend listening on ${PORT}`));
│
├── frontend/
│   ├── index.html
<!DOCTYPE html>
<html lang="ar">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>FlatDrive Game</title>
<link rel="stylesheet" href="style.css">
</head>
<body>
<div id="app">
  <h1>🚗 FlatDrive Game</h1>
  <p>الرصيد: <span id="playerBalance">0</span> USDT</p>
  <p>الرصيد الاحتياطي: <span id="fundBalance">0</span> USDT</p>
  <button id="creditBtn">إضافة رصيد (Credit)</button>
  <input type="number" id="withdrawAmount" placeholder="مبلغ السحب" />
  <input type="text" id="withdrawTo" placeholder="عنوان TRON" />
  <button id="withdrawBtn">سحب</button>
</div>
<script src="app.js"></script>
</body>
</html>
│
│   ├── style.css
body { font-family: Arial, sans-serif; text-align:center; padding:2rem; background:#0f172a; color:#e6eef8;}
button { padding:0.5rem 1rem; margin:0.5rem; cursor:pointer; border-radius:6px; border:none; background:#0ea5a6; color:#041014; }
input { padding:0.5rem; margin:0.5rem; width:200px; border-radius:6px; border:1px solid rgba(255,255,255,.06); background:#02121a; color:#fff; }
│
│   └── app.js
const API = "http://localhost:3000";

async function fetchBalances() {
  const res = await fetch(`${API}/balances`);
  const data = await res.json();
  document.getElementById("playerBalance").innerText = data.playerBalance;
  document.getElementById("fundBalance").innerText = data.fundBalance;
}

document.getElementById("creditBtn").onclick = async () => {
  const amount = parseFloat(prompt("أدخل المبلغ لإضافته:"));
  if(!amount || amount<=0) return alert("مبلغ غير صالح");
  const res = await fetch(`${API}/credit`, {
    method:"POST",
    headers:{"Content-Type":"application/json"},
    body:JSON.stringify({ totalUsd: amount })
  });
  const data = await res.json();
  if(data.ok) alert("تم إضافة الرصيد بنجاح"); else alert(data.error || "خطأ");
  fetchBalances();
}

document.getElementById("withdrawBtn").onclick = async () => {
  const amount = parseFloat(document.getElementById("withdrawAmount").value);
  const to = document.getElementById("withdrawTo").value.trim();
  if(!amount || amount<50) return alert("الحد الأدنى 50 USDT");
  if(!to || !to.startsWith("T")) return alert("عنوان TRON غير صالح");
  const res = await fetch(`${API}/withdraw`, {
    method:"POST",
    headers:{"Content
